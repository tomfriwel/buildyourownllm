import torch
import torch.nn as nn

# 定义一个嵌入层，颜色类别大小为5，嵌入维度为3（对应RGB值）
embedding = nn.Embedding(5, 3) # 5种颜色，每种颜色用3个值（R, G, B）表示

print(embedding)

# 输入是一个颜色类别的索引序列
input_indices = torch.tensor([0, 1, 2, 3, 4]) # 假设索引0-4分别表示红、绿、蓝、黄、紫

print("输入的颜色类别索引:", input_indices)

# 输出是对应的RGB嵌入向量
output = embedding(input_indices)
print("对应的RGB嵌入向量:", output)

# 嵌入层就像一个颜色查找表：
# 假设你有一个颜色类别的列表，每个颜色都有一个编号（索引），假设索引0-4分别表示红、绿、蓝、黄、紫
# 而嵌入层的作用就是把这些编号映射到一个RGB值的向量。 
# 这个向量可以看作是颜色的“位置”，表示它的RGB值。
# 通过训练，嵌入层会学习到每个颜色的RGB值，
# 使得相似的颜色在嵌入空间中也相近。
# 例如，红色可能被映射为 [1.0, 0.0, 0.0]，
# 绿色可能被映射为 [0.0, 1.0, 0.0]，
# 蓝色可能被映射为 [0.0, 0.0, 1.0]，
# 而黄色可能被映射为 [1.0, 1.0, 0.0]
# 这样，嵌入层就能把颜色类别转换为一个多维空间中的点，
# 这个点的坐标就是颜色的RGB值。
# 实际中，嵌入层每次生成的向量都是随机初始化的，
# 但在训练过程中，这些向量会根据数据的分布和模型的需求不断调整，
# 使得相似的颜色类别在嵌入空间中也会更接近。
# 这就像是一个调色板，每种颜色都有一个具体的RGB值，
# 而这些RGB值是通过训练学习到的，能够反映颜色之间的关系。

# 类比：
# 如果把颜色类别比作颜色的名字，嵌入层就像是调色板。
# 每个颜色在调色板上都有一个具体的RGB值，
# 而这些RGB值是通过训练学习到的，能够反映颜色之间的关系。
# 比如，相近的颜色在RGB空间中会更接近，
# 同样，语义相近的颜色类别在嵌入空间中也会更接近。